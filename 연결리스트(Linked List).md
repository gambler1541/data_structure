## 연결리스트(Linked List)

#### 연결리스트와 배열의 차이

### 속도

* 데이터에 대한 접근 속도
	* 인덱스만 있다면 배열의 시간복잡도는 `O(1)`
	* 연결리스트는 최소 한 번은 리스트를 순회해야 하므로 `O(n)`

* 데이터 삽입 속도
	* 배열에 공간이 많이 남아있고 맨 끝에 삽입한다면 - `O(1)`
	* 연결리스트는 어느 곳에 삽입하던지 O(n)의 시간에 근접(중간 삽입이 없다면 `O(1)`
	* 데이터를 중간이나 맨 앞에 삽입할 경우 그 이후의 데이터를 한 칸씩 미뤄야하는 추가과정과 시간이 소요(연결리스트는 필요없음)
	* 배열의 경우 데이터 삽입시 모든 공간이 차버렸으면, 새로이 할당하여 메모리 공간이 필요
	
* 데이터 삭제의 속도
	* 삽입과 동일
	* 배열의 데이터 삭제 경우 그 위치의 데이터를 삭제 후, 전체적으로 한 칸씩 앞당김
	* 연결리스트의 경우 예외조건들의 처리가 필요(코드 복잡성이 증가)

* 삽입과 삭제가 번번히 이루어진다면 - `연결리스트`
* 이미 만들어진 구조에서 데이터의 접근만 필요하면 - `배열`

### 자료구조 활용

* `리스트` : 일련의 동일한 타입의 항목들을 의미
	* 실생활에서 볼 수 있는 리스트 : 학생 명단, 시험 성적, 서점의 신간 서적, 상점의 판매 목록, 실시간 급상승 검색어, 버킷 리스트 등
	* 리스트에 관련된 기본 연산 : 탐색, 삽입, 삭제

## 단순연결리스트(singly linked list)

* 단순연결리스트에서는 삽입이나 삭제 시 항목들의 이동이 필요없음
* 탐색을 하려면 항상 첫 노드부터 원하는 노드를 찾을 때까지 차례로 방문
	* 순차탐색(Sequential Search)을 해야함

##### 단순연결리스트의 활용

* 스택, 큐, 해싱의 체이닝, 트리
	
## 이중연결리스트(doubly linked list)

> 각 노드가 두 개의 레퍼런스를 가지고 각각 이전 노드와 다음 노드를 가리키는 연결리스트

##### 단순연결리스트와의 차이

* 단순연결리스트는 다음 노드의 레퍼런스만으로 노드들이 연결되어 있음
* 삽입이나 삭제할 때 반드시 이전 노드를 가리키는 레퍼런스를 추가로 알아야 함
* 역방향으로 노드들을 탐색할 수 없음

##### 이중연결리스트는 이러한 단점을 보완했으나, 각 노드마다 1개의 레퍼런스(이전노드를 가리키는 레퍼런스)를 추가로 저장해야 한다는 단점을 가짐

##### 이중연결리스트의 활용

* 데크(Deque), 이항힙(Binomial Heap), 피보나치 힙과 같은 우선순위큐

## 원형연결리스트(circular linked list)
> 마지막 노드가 첫 노드와 연결된 단순연결리스트

* 장점
	* 마지막 노드를 참조하는 `last`가 단순연결리스트의 `head`역할을 함
	* 마지막 노드와 첫 노드를 O(1)시간에 방문할 수 있는 장점
	* 리스트가 empty가 아니면 어떤 노드도 None을 가지고 있지 않으므로 프로그램에서 None 조건을 검사하지 않아도 됨

* 단점
	* 반대 방향으로 노드들을 방문하기 쉽지 않음
	* 무한 루프가 발생할 수 있음에 유의

##### 원형연결리스트의 활용
* 여러 사람이 차례로 돌아가며 플레이하는 게임을 구현, 많은 사용자들이 동시에 사용하는 컴퓨터에서 CPU 시간을 분할하여 작업들에 할당하는 운영체제, 이항힙, 피보나치힙



